package org.fortiss.smg.actuatorclient.apros.impl;import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.concurrent.TimeoutException;import org.osgi.framework.BundleActivator;import org.osgi.framework.BundleContext;import org.fortiss.smg.actuatormaster.api.AbstractClient;import org.fortiss.smg.actuatormaster.api.ActuatorMasterQueueNames;import org.fortiss.smg.actuatormaster.api.IActuatorMaster;import org.fortiss.smg.actuatormaster.api.AbstractConnector.IOnConnectListener;import org.fortiss.smg.config.lib.WrapperConfig;import org.fortiss.smg.remoteframework.lib.DefaultProxy;import org.slf4j.LoggerFactory;public class ActuatorClientActivator extends AbstractClient implements BundleActivator  {       ActuatorClientImpl implClient;	private List<ActuatorClientImpl> clients = new ArrayList<ActuatorClientImpl>();	IActuatorMaster master4config = null;    // Logger from sl4j    private static org.slf4j.Logger logger = LoggerFactory.getLogger(ActuatorClientActivator.class);    @Override    public void start(BundleContext context) throws Exception {    	// register here your services etc.		// DO NOT start heavy operations here - use threads		/*		 * Try to connect to Master to get the wrapper's config file		 */		ArrayList<WrapperConfig> configList = new ArrayList<WrapperConfig>();		DefaultProxy<IActuatorMaster> proxyMaster = new DefaultProxy<IActuatorMaster>(				IActuatorMaster.class,				ActuatorMasterQueueNames.getActuatorMasterInterfaceQueue(),				5000);		try {			master4config = proxyMaster.init();		} catch (TimeoutException e) {			logger.error("ActuatorClient: Unable to connect to master (Timeout).");		}		/*		 * If we have connection try to get the wrapper's config file		 */		if (master4config != null) {			try {				configList = master4config.getWrapperConfig("apros");			} catch (TimeoutException e) {				logger.error("ActuatorClient: Unable to connect to master (Timeout).");			} finally {				try {					proxyMaster.destroy();				} catch (IOException e) {					logger.info("Unable to close con. for queue:"							+ this.clientId);				}			}			/*			 * For each received wrapper config instance (possibly the same			 * wrapper is used for multiple (physical) devices			 */			if (configList.size() > 0) {				for (WrapperConfig config : configList) {					final String clientKey = config.getKey();					final String clientIDextension = config.getHost();			     					implClient = new ActuatorClientImpl(config.getHost(),							config.getPort(), config.getWrapperID(),							config.getPollingfrequency(), config.getUsername(),							config.getPassword(), config.getPath());					// Register at Actuator Master (self, human readable name					// for					// device)					registerAsClientAtServer(implClient,							config.getWrapperName(), new IOnConnectListener() {								@Override								public void onSuccessFullConnection() {									implClient.setMaster(master);									implClient.setClientId(clientId);									implClient.activate();									logger.info("ActuatorClient[" + clientKey											+ "-" + clientIDextension											+ "] is alive");									clients.add(implClient);								}							});				}				logger.info("ActuatorClient.Apros is alive");;			} else {				logger.info("No Configuration available");			}		} else {			proxyMaster.destroy();			logger.debug("ActuatorClient.Apros could not read config from Master");			this.stop(context);		}    }    @Override    public void stop(BundleContext context) throws Exception {        // REMEMBER to destroy all resources, threads and do cleanup        logger.info("ActuatorClient.Apros is dead");    }}